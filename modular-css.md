# 第三部分 大型应用中的CSS

编程不仅要考虑电脑，还要考虑团队里的其他成员。掌握好浏览器如何渲染CSS是很重要的，了解如何在项目中编写和组织CSS也很重要。本部分（第9章和第10章）将会展示如何组织CSS代码，使其容易理解和维护。



# 第9章 模块化CSS

> 本章内容
>
> * 项目规模持续增长时暴露出来的问题
> * 使用模块组织CSS代码
> * 避免提升选择器的特异性
> * 调研流行的CSS方法论



在第一部分和第二部分，我们明白了CSS的一些晦涩难懂的概念，掌握了元素在页面中编排的方式。我们也了解了盒模型、外边距叠加、层叠上下文、浮动和弹性布局。这些技术对于新建项目尤其重要。然而，在实际的软件开发过程中，我们的时间和精力不仅用在写新代码上，还要用于持续更新和维护现有代码。对于CSS来说，这就带来了一堆新问题。

修改旧样式的时候，受影响的页面和元素有可能是不确定的。有个老笑话是这么说的：两个CSS属性走进了一间酒吧，结果另一间酒吧里的高脚凳摔倒了。问题就来了：要怎么确保修改后的影响范围和预期一致呢？怎样才能不影响我们不想修改的那些元素？

本部分将讨论这些问题。我们会谈到CSS架构，不会涉及太多具体样式的书写，而是更多地关注CSS选择器和匹配到的HTML元素。如何组织代码结构，决定了后续能否安全地修改代码，不会有一些多余的副作用。我们从理解模块化CSS开始，这是本章的重点。

**模块化CSS**是指把页面分割成不同的组成部分，这些组成部分可以在多种上下文环境中重复使用，并且互相之间没有依赖关系。最终目的是，当我们修改其中一部分的CSS时，不会对其他部分产生不可预知的影响。

这跟组合家具的原理类似。举个例子，宜家厨房不是建造一个大型的橱柜单元，而是设计成各种独立的小件，让顾客可以任选购买。这些小件看上去风格一致，组合起来也会很和谐。这样一来，顾客就可以在布置的时候把这些小件随意摆放到自己喜欢的位置。模块化CSS也是这样，不是直接编写一个大型网页，而是以特殊的方式编写页面的每个组成部分，然后按你需要的效果组合在一起。

在计算机科学中，编写模块化代码并不是什么新潮的做法，但开发人员近几年才开始将其引入到CSS。随着现代网站和Web应用体量越来越大、越来越复杂，我们不得不探寻一些方法来管理日益庞大繁杂的样式表。

之前的样式表可以使用选择器在页面上随意修改，模块化的样式则允许开发人员添加一些限制。我们把样式表的每个组成部分称为**模块**，每个模块独立负责自己的样式，不可以影响其他模块内的样式，即在CSS里引入了软件封装的原则。

> **封装**——相关的函数和数据集合在一起组成对象，通常用来隐藏结构化对象内部的状态或值，从而使外部因素不能操作内部。

CSS中没有数据和传统函数的概念，但是有选择器和被选择器规则命中的页面元素。为了达到封装的目的，选择器和那些选中的元素将会成为模块的组成部分，并且每个模块都只负责很少数量的DOM元素的样式。

有了封装的思想，我们就可以为页面上那些彼此分立的组件来定义模块了，像导航菜单、对话框、进度条、缩略图，等等。每个模块可以通过为DOM元素设置一个独一无二的的类名来识别。同时，每个模块包含一系列子元素构建成页面上的组件。模块内部可以嵌套其他模块，最终构成完整的页面。



## 9.1 基础样式：打好基础

开始写模块化样式之前，需要先配置好环境。每个样式表的开头都要写一些给整个页面使用的通用规则，模块化CSS也不例外。这些规则样式通常被称为**基础样式**，其他的样式都是构建在这些基础样式之上的。基础样式本身并不是模块化的，但它会为后面编写模块化样式打好基础。

新建一个网页和一个样式表，把下列清单中的基础样式粘贴到CSS中。这里的清单只是列举了你可能用到的一些基础样式。

**清单9.1 添加基础样式**

> [P235  代码清单一]
>
> Box sizing reset(chapter 3)   重置盒模型计算规则（详见第3章）
>
> Default font size for the page   设置页面默认使用的字体 [To编辑：原文是font size，但是这句CSS里的font-family并不是用来设置字体大小的，只是用来设置字体，故翻译时忽略了size]



其他常用的基础样式还包括链接的颜色、标题的样式、外间距等。`<body>`标签默认有很小的外间距，你可能会考虑将它的外间距去掉。根据项目的实际情况，你也可能想为表单字段、表格和列表等添加一些样式。

> **小技巧**
>
> 这里推荐一个叫normalize.css的库，这个小样式表可以协助消除不同的客户端浏览器渲染上的不一致。可以从[https://necolas.github.io/normalize.css/](https://necolas.github.io/normalize.css/)下载，然后添加到自己的样式表前面作为基础样式的一部分。

基础样式应该确保是通用的，只添加那些影响到页面上大部分或者全部内容的样式。选择器不应该使用类名或者ID来匹配元素，只用标签类型或者偶尔用用伪类选择器。核心思想是这些基础样式提供了一些默认的渲染效果，但是后续又可以很方便地根据实际需要去覆盖样式。

基础样式配置完成以后，一般不会再修改。我们会在基础样式的稳定表现之上，去构建模块化CSS。样式表中，基础样式后面的内容将主要由各种模块组成。

## 9.2 一个简单的模块

下面我们来创建一个短消息通知的模块。因为每个模块都需要取一个独一无二的名字，所以我们把这个模块叫作message。为了更好地吸引用户的注意，可以加上一些颜色和边框效果（如图9.1）。

>[p235  图一]
>
>图9.1 消息模块

这个模块使用一个类名为`message`的`div`作为标签。添加下面的代码到网页中：

**清单9.2 为消息模块添加标记**

> [p236 代码清单一]

模块的CSS是一系列样式规则的集合，通过类名指向模块。CSS中设置了内边距、边框、边框圆角和颜色。把下列代码添加到样式表，放在基础样式后面，就可以把这些样式应用到消息模块了。

**清单9.3 实现消息模块**

> [p236 代码清单二]
>
> Targets the Message module by its class name   通过类名指向消息模块

你应该很熟悉这些属性，至少现在看上去没什么不同，就跟书里你看到的其他CSS代码差不多。实际上，我们写过的代码里有很多是符合模块化CSS的原则的，只是之前没有注意到罢了。下面我们来分析一下这些CSS是如何模块化的。

模块的选择器由单一的类名构成，这非常重要。选择器里没有其他规则来约束这些样式仅作用在页面上的某些地方。对比一下，如果使用一个类似`#sidebar .message`这样的选择器，就意味着这个模块只能用在`#sidebar`元素内部。没有这些约束，模块就可以在任意上下文环境中重复使用。

通过给元素添加类名，就可以把这些样式复用到很多场景，比如表单输入的时候给用户一些反馈，提供一些醒目的帮助文字，或者提醒用户注意免责声明条款等。使用相同的组件，就产生了一套风格一致的UI。所有用到的地方都看上去一样，不会出现有的地方深蓝绿色有色差、有的地方内边距偏大等问题。

我曾经在CSS没有被模块化的项目里工作过。其中有一个项目中出现了好几个相似的按钮，`.save-form button`、`.login-form button`和`.toolbar .options button`。样式表里多次出现重复代码，尽管并不是完全的复制。重复是为了获取一致的体验，但是随着时间的推移，不同的按钮之间还是产生了一些不一样的改变。结果就是，有的按钮内边距稍有不同，有的按钮红得更鲜艳。

解决办法就是把按钮重构成一个独立可复用的模块，不受页面位置的限制。创建模块不但可以精简代码（更少的重复），还可以保证视觉一致性。这样看上去更专业，不会给人仓促堆砌的感觉。用户在潜意识里也会更容易相信我们的产品。

### 9.2.1 模块的变化

保持一致性确实不错，但有时候可能需要特意去避免一致。上面的消息模块很好用，但某些特定情况下我们需要它看起来有些不同。比如，我们需要显示一条报错的消息，这时候应该使用红色而不是之前的深蓝绿色。再比如，我们可能想要在纯信息的消息和象征操作成功的通知（比如保存成功的时候）之间做一些区分。可以通过定义`修饰符`(modifiers)来实现。

通过定义一个以模块名称开头的新类名来创建一个修饰符。举个例子，消息模块的“error”修饰符应该叫做“message-error”。因为包含模块名称，我们很容易分辨出这个类属于消息模块。

> **注意**
>
> 常用的写法是使用两个连字符来表示一个修饰符，比如“message--error”。

下面我们为模块创建三个修饰符：成功、警告和错误。添加下列代码到样式表：

**清单9.4 带修饰类的消息模块**

> [p237 代码清单一]
>
> Base Message module 基础消息模块
>
> Success modifier changes message to green. “成功”修饰符变成了绿色
>
> Warning modifier changes message to yellow. “警告”修饰符变成了黄色
>
> Error modifier changes message to red. “错误”修饰符变成了红色

修饰符的样式不需要重新定义整个模块，只需要覆盖要改变的部分。在这个示例中，意味着只需要修改文本、边框和背景的颜色。

如下面代码所示，把主模块类名和修饰符类名同时添加到元素上，就可以使用修饰符了。这样既应用了模块的默认样式，又可以在有需要的时候利用修饰符重写部分样式。

**清单9.5 一个使用了错误修饰符的消息模块实例**

> [p238 代码清单一]
>
> Adds both classes to the element 把模块和修饰符的类名都添加到元素上

同样地，有需要的时候也可以使用成功和警告修饰符。这些修饰符只是改变了模块的颜色，有些可能会改变模块的尺寸甚至外观。

**按钮模块的变体**

下面创建另一个模块和一些变体。我们将实现一个按钮模块，以及尺寸大小和颜色可选的变体（如图9.2）。我们可以用不同的颜色为按钮添加视觉语义。绿色代表积极的行为，比如保存和提交表单；红色意味着警告，有利于避免使用者不小心点击到取消按钮。

**图9.2 使用了不同的尺寸和颜色修饰符的按钮**

> [p238 图一]

下面的代码清单给出了这些按钮的样式，包括基础按钮模块和四个修饰符类：两个尺寸修饰符和两个颜色修饰符。添加这些代码到样式表：

**清单9.6 按钮模块和修饰符**

> [p238 代码清单二]
>
> Base button styles 基础按钮样式
>
> Green success color variant 绿色的成功颜色变体
>
> Red danger color variant 红色的危险颜色变体
>
> Small variant 小号变体
>
> Large variant 大号变体

通过设置字号的大小来实现尺寸修饰符。在第二章我们使用过这个技巧：通过更改字号来调整元素相对单位em的大小，进而改变内边距和边框圆角的大小，而不需要重写已经定义好的值。

> **小技巧**
>
> 要把一个模块所有的代码集中起来放在同一个地方，这样一个接一个的模块，就会组成我们最终的样式表。

有了这些修饰符，写HTML的时候就有了多种选择。我们可以根据按钮的重要程度来添加修饰符类名，修改按钮的大小；也可以选择不同的颜色来为用户提供语境含义。

下面代码里的HTML，组合使用修饰符来创建多个按钮。可以添加这些代码到页面查看实际效果。

**清单9.7 使用修饰符创建多种类型的按钮**

> [p239 代码清单二]
>
> Button module with large modifier 带大号按钮修饰符的按钮模块
>
> Button module with success modifier 带成功按钮修饰符的按钮模块
>
> Button module with danger and small modifier 带危险和小号按钮修饰符的按钮模块

这里的第一个按钮是大号的。第二个按钮是绿色，代表操作成功的颜色。第三个按钮有两个修饰符：一个是改变颜色（危险修饰符），一个改变大小（小号修饰符）。最终效果如图9.2所示。

双连字符的写法可能看起来有点儿多余。当我们要创建名字很长的模块的时候，比如导航菜单或者文章摘要，好处就显现出来了。为这些冗长的模块类名添加的修饰符类似`nav-menu--horizontal`或者`pull-quote--dark`。

双连字符的写法可以很容易区分哪部分是模块名称，哪部分是修饰符。`nav-menu--horizontal`和`nav--menu-horizontal`分别代表了不同的含义。这样一来，即使项目里有很多名称相似的模块，依然很容易分辨它们。

> **注意**
>
> 这种双连字符的写法是从一个叫**BEM**的CSS命名规范流行起来的。本章快到最后的时候，会介绍BEM和一些类似的其他方法论。

**不要使用语境依赖的选择器**

假设我们正在维护一个网站，里面有浅色调的下拉菜单。有一天老板说，页面头部的下拉菜单需要改成带白色文本的深色调。

如果没有模块化CSS，我们可能会使用类似`.page-header .dropdown `的选择器，先选中要修改的下拉菜单。然后通过选择器写一些样式，覆盖dropdown类提供的默认颜色。现在要写模块化CSS，这样的选择器是严格禁用的。虽然使用多级选择器可以解决当下的需要，但接下来可能会带来很多问题。下面我们来分析一下。

首先，我们必须考虑把这段代码放在哪，是和页面头部的样式放在一起，还是跟下拉菜单放在一起？如果我们添加太多类似的单一目的的规则，样式之间毫无关联，到最后样式表会变得杂乱无章。并且，如果我们后面需要修改样式，你还能想起来放在哪里吗？

其次，这种做法增加了选择器特异性。当下次需求变更再修改代码的时候，我们需要满足或者继续增大特异性。

第三，后续我们可能需要在其他场景用到深色调的下拉列表。刚才创建的这个下拉列表，是被限制在页面头部使用的。如果侧边栏也需要同样的下拉列表，我们就得为这堆样式添加新的选择器来匹配两个场景，或者完整地复制一遍样式。

最后，重复使用这种写法会产生越来越长的选择器，让CSS跟特定的HTML结构绑定在一起。举个例子，如果有个这样的选择器，`#products-page .sidebar .social-media div:first-child h3`，样式集就会和指定页面的指定位置紧紧耦合。

这些问题是开发人员处理CSS的时候遭受挫折的根源。样式表越长，情况越糟。新样式需要覆盖旧样式的时候，选择器特异性会持续增长。到后面不知不觉地就会发现，我们写了一个选择器，其中包含两个ID和5个类名，只是为了匹配到一个复选框表单。

在样式表中，元素被各种彼此不相关的选择器匹配，这样很难找到它使用的样式。理解整个样式表的组织方式变得越来越困难，你搞不明白它是怎样把页面渲染成这样的。搞不懂代码就意味着bug变得常见，可能很小的改动就会弄乱大片的样式。删除旧代码也不安全，因为你不了解这段代码是干什么的，是否还在用。样式表越长，问题就愈发严重。模块化CSS就是要尝试去解决这些问题。

当模块需要有不同的外观或者表现的时候，就创建一个可以直接应用到指定元素的修饰符类。比如，`.dropdown--dark`，而不是写成`.page-header .dropdown`。通过这种方式，模块本身，并且只能是它本身，可以决定自己的样式表现。其他模块不能进入别的模块内部去修改它。这样一来，深色下拉列表并没有绑定到深层嵌套的HTML结构上，就可以在页面上需要的地方随意使用。

绝对不要使用基于页面位置的后代选择器来修改模块。牢牢遵守这个原则，就可以有效避免我们的样式表变成一堆难以维护的代码。

### 9.2.2 多元素模块

我们已经创建了消息和按钮两个模块，简单又好用，它们都是由单个元素组成的。但是有很多模块需要多个元素。我们不可能只靠一个元素就实现下列菜单或者模态框。

下面我们来创建一个更复杂的模块。这是一个媒体对象（如图9.3），就跟第四章我们做的那个差不多（4.5.1节）。

> [p241 图一]
>
> 图9.3 由4个元素组成的媒体模块

这个模块由4个元素组成：`div`容器、容器包含的一张图片和正文、正文里的标题。跟其他模块一样，我们会给主容器添加`media`类名来匹配模块名称。对于图片和正文，可以使用类名`media__image`和`media__body`。这些类名以模块名称开头，后跟双下划线，然后是子元素的名称（这是BEM命名规范里的另一种约定）。就跟双连字符代表的修饰符一样，这样的类名可以一目了然地告诉我们这个元素扮演了什么角色、属于哪个模块。

媒体模块的样式列在下面了，可以直接添加到样式表。

**清单9.8 包含子元素的媒体模块**

> [p241 代码清单一]
>
> [p242 代码清单一]
>
> Main container 主容器
>
> Clearfix 清除浮
>
> The image and body sub-elements 图片和正文子元素
>
> The title within the body 正文里的标题

你会发现并不需要使用很多后代选择器。图片是媒体模块的一个子元素，所以可以使用选择器`.media > .media__image `，但这没啥必要。因为`media__image`类名包含了模块的名称，已经确保是独一无二的了。

正文标题确实直接使用了后代选择器。其实也可以用`media__title`类（或者`media__body__title`，这样可以完整地表示出在整个层级中的位置），但是大部分时候没必要。在这种情况下，`h4`标签已经足够语义化，表明这是媒体组件的标题。这样一来，标题就不能使用其他的HTML标签（`<h3>`或者`<h5>`）了。如果你不太喜欢这么严格的限制，可以改成使用类名来匹配元素。

添加模块的标记到页面中：

**清单9.9 媒体模块的HTML**

> [p242 代码清单二]
>
> Image sub-element 图片子元素
>
> Body sub-element 正文子元素
>
> Title sub-element 标题子元素

这是个多功能的模块，可以工作在各种尺寸的容器内部，随着容器宽度自适应调整。正文可以包含多个段落，也可以使用不同尺寸的图片（可以考虑为图片添加`max-width`属性，防止图片挤出正文区域）。

**同时使用变体和子元素**

