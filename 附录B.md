# 附录B 预处理器

对于现代CSS工作流来讲，使用预处理器是必不可少的一部分。预处理器为提升代码书写效率提供了很多便利，而且有助于维护基础代码。举个例子，我们有时候只需要写几行代码，然后在整个样式表中复用它。

预处理器的工作原理是把我们写的源文件转译成标准CSS样式表。大部分情况下，源文件看上去和标准CSS差不多，只是增加了一些额外的特性。一个使用了预处理器变量的简单示例，看上去大概是这样的：

> [p422 代码片断一]

这段代码片断定义了一个名为`$brand-blue`的变量，用在了样式表后面的两个不同的地方。使用Sass预处理器运行的时候，整个样式表中的变量都被替换了，输出了下面的CSS：

> [p422 代码片断二]

我们需要明确一件事情，对于浏览器而言，因为最终输出是标准CSS，预处理器不会向语言添加任何新特性。但对于作为开发者的我们来讲，预处理器确实提供了许多方便。

在前面的例子中，使用变量代表颜色值，就可以多次重复使用它，而不需要每次复制粘贴十六进制码。生成输出文件的过程中，预处理器替我们做了重复复制这件事情。这也意味着我们可以在一个地方修改变量值，改动会传递到整个样式表。

预处理器有好几种，其中比较流行的两个是`Sass`（[https://sass-lang.com/](https://sass-lang.com/)）和`Less`（[http://lesscss.org/](http://lesscss.org/)）。Sass是最常见的预处理器，接下来我们会占用较多的篇幅来介绍它。Less和Sass其实比较类似，主要在一些语法细节上有所区别。举例来说，Sass使用$来表示变量（`$brand-blue`），而Less使用@符号（`@brand-blue`）。附录中提到的所有Sass特性，Less都支持，可以浏览Less的官方文档查看语法上的区别。

## B.1 Sass

使用Sass之前，需要先确定几件事情。首先是使用哪种实现方案。Sass是用Ruby写的，但这种实现方式在编译大型样式表的时候比较慢，所以建议使用`LibSass`，这是用C/C++实现的Sass编译器。

如果你对JavaScript和Node环境比较熟悉，可以通过npm包管理工具安装node-sass，也可以获取LibSass。如果还没有安装Node.js，可以在[https://nodejs.org](https://nodejs.org)上找到它（免费），按照上面的指导进行下载安装即可。后面会介绍相关的操作命令，但如果你想了解更多npm或者遇到问题需要求助，可以访问[https://docs.npmjs.com/getting-started/](https://docs.npmjs.com/getting-started/)。

### B.1.1 安装Sass

要安装Sass，先在终端中新建一个项目目录，并进入该目录。然后运行下面两条命令：

- `npm init -y`——初始化一个新的npm项目，创建package.json文件。关于该文件的更多信息可以查看第十章（10.1.1节）。
- `npm install --save-dev node-sass`——安装`node-sass`包，并把它作为开发依赖写入package.json。

> **注意**
>
> 在Windows系统中，还需要安装`node-gyp`包。更多信息可以查看[https://github.com/sass/node-sass#install](https://github.com/sass/node-sass#install)。

第二个需要确认的事情是使用哪种语法。Sass支持两种语法：Sass和SCSS。它们的语言特性是一样的，但Sass语法去掉了所有的花括号和分号，严格使用缩进来表示代码结构。比如：

> [p424 代码片断一]

这有点类似于Ruby和Python这样的编程语言，空格是有意义的。SCSS语法使用花括号和分号，所以看起来更像标准CSS。例如：

> [p424 代码片断二]

相对来讲，使用SCSS更普遍一些。如果你不太确定，建议选择SCSS，我们在这篇附录中也是使用SCSS。

> **注意**
>
> SCSS文件使用.scss扩展名，Sass文件使用.sass扩展名。

### B.1.2 运行Sass

现在已经安装好了Sass，我们开始创建样式表。在项目目录新建两个子文件夹，分别叫做sass和build。我们会把源文件放在sass文件夹，Sass会使用这些文件来生成CSS文件，并放到build文件夹。接下来，编辑package.json文件。按照下面的代码清单修改`scripts`入口。

**清单B.1 为package.json添加一条sass命令**

> [p424 代码清单一]

这样就定义了一条`sass`命令，运行的时候会把sass/index.scss编译成build/styles.css这个新文件。目前项目中还不存在sass/index.scss文件，先创建它，Sass源码会放在这里面。运行`npm run sass`，执行这条命令，就会生成（或者覆盖）build/styles.css样式表。

> **小贴士**
>
> 像Grunt、Gulp和Webpack这些常见的任务构建工具，都会有一些可以使用的插件，比如gulp-sass。如果你想使用插件，可以找一款Sass或者Less的，集成到自己最熟悉的工作流之中。

### B.1.3 理解核心的Sass特性

前面已经展示过Sass变量的例子了（`$brand-blue`）。把下面清单中的代码添加到index.scss文件中，看看Sass是如何编译的。

**清单B.2 Sass变量**

> [p425 代码清单一]
>
> Defines a variable
>
> 定义变量
>
> Uses the variable
>
> 使用变量
>
> Uses the variable
>
> 使用变量

运行`npm run sass`，可以把上面的代码编译成CSS。输出文件（build/styles.css）看起来应该是这样的：

> [p425 代码片断一]

变量已经被替换为十六进制颜色值，浏览器现在可以直接运行了。同时Sass还生成了一个源映射文件，并添加一条注释到样式表的底部，用来标明`源映射`的路径。

> `源映射`（source map）是一个特殊文件，计算机可以用它来追踪生成后的代码（在我们这里是CSS）中每一行对应的源代码中的那一行（Sass）。这个映射文件可以用在一些调试器中，包括浏览器的开发者工具。

你可能注意到编译后的代码没有被很好地格式化，闭合花括号带到了上一行，有时候空行也可能会删除。这些都没关系，因为浏览器是不会关心这些空格的。但我会把附录里接下来的例子中的代码格式处理好，这样结构清晰更易于理解。

**行内计算**

Sass同样支持使用+、-、*、/和%（除法取整）进行行内计算。这样我们就可以从一个初始值获得多个值，如下面清单所示。

> [p425 代码清单二]
>
> [p426 代码清单一]
>
> Uses a variable 使用变量
>
> Multiplies variable by two 变量乘以2

使用`npm run sass`编译源码，生成了下面的输出：

> [p426 代码片断一]

这个特性在两个值相关但不同的时候特别有用。在例子中，无论`$padding-left`的值是多少，`note-body`的左侧内边距总是`note-author`的两倍。

**嵌套选择器**

Sass允许在代码块内嵌套选择器。你可以使用嵌套把有关联的代码分到一组，如下所示。

> [p426 代码清单二]
>
> Nested selector
>
> 嵌套的选择器
>
> Ampersand indicates where the outer selector will be appended.
>
> &符号代表外层选择器将被插入的位置

Sass会把外层代码块的选择器与嵌套选择器合并。示例代码会被编译为：

> [p426 代码片断二]

默认情况下，外层的`.site-nav`选择器会自动添加到编译代码的每个选择器前面，拼接的位置还会插入一个空格。要修改默认操作，可以使用&符号代表外层选择器想要插入的位置。

> **警告**
>
> 嵌套会提升最终生成的选择器的优先级，使用嵌套的时候要小心，避免嵌套层级过深。

也可以在代码块内嵌套媒体查询，这样可以用来避免重复书写相同的选择器，就像下面清单展示的这样。

**清单B.5 嵌套媒体查询**

> [p427 代码清单一]
>
> Media query inside a declaration block
>
> 代码块内的媒体查询

这段代码将会编译成：

> [p427 代码片断一]

这样的话，如果你要修改选择器，就不必再去媒体查询里面修改对应的选择器了。

**局部文件（partials）**

局部文件可以允许你把样式分割成多个独立的文件，Sass会把这些文件拼接在一起生成一个文件。使用局部文件可以按照自己的想法随意组织文件，但最终只提供给浏览器一个文件，这样可以减少网络请求的数量。

在项目中新建sass/button.scss文件，添加下列样式到文件中。

**清单B.6 按钮局部样式表**

> [p427 代码清单二]

然后在`index.scss`中使用`@import`规则引入这个局部样式表，写法如下：

**清单B.7 引入局部文件**

> [p428 代码清单一]
>
> Path to the partial file
>
> 局部文件的路径

运行Sass的时候，局部文件会被编译，然后插入到`@import`规则指定的地方。

我认为这是预处理器最重要的特性。随着样式表体积越来越大，滚动上千行代码去寻找样式表中相关的部分变得非常困难。使用这个特性可以把样式表打散，变成一系列小巧的模块，同时又不会带来网络性能开销。想要了解更多，可以查看第九章的“预处理器与模块化CSS”补充内容。

**混合（mixins）**

`混合`是一小段CSS代码块，可以在样式表任意地方复用。如果有一段特定的字体样式需要在多个地方使用，或者类似清除浮动这样常用的重复规则（第四章4.2节讨论过），使用混合就比较合适。

混合使用`@mixin`来定义，使用`@include`来调用。这里有个清除浮动的混合使用案例。

**清单B.8 清除浮动混合**

> [p428 代码清单二]
>
> Defines a mixin named clearfix
>
> 定义一个混合，命名为clearfix
>
> Nested selectors
>
> 嵌套选择器
>
> Applies the mixin
>
> 调用混合

预处理器会提取mixin中的代码，替换到`@include`规则所在的位置。最终的代码看起来是这样的：

> [p428 代码片断一]
>
> [p429 代码片断一]

注意，最终编译生成的代码中