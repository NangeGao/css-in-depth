# 附录B 预处理器

对于现代CSS工作流来讲，使用预处理器是必不可少的一部分。预处理器为提升代码书写效率提供了很多便利，而且有助于维护基础代码。举个例子，我们有时候只需要写几行代码，然后在整个样式表中复用它。

预处理器的工作原理是把我们写的源文件转译成标准CSS样式表。大部分情况下，源文件看上去和标准CSS差不多，只是增加了一些额外的特性。一个使用了预处理器变量的简单示例，看上去大概是这样的：

> [p422 代码片断一]

这段代码片断定义了一个名为`$brand-blue`的变量，用在了样式表后面的两个不同的地方。使用Sass预处理器运行的时候，整个样式表中的变量都被替换了，输出了下面的CSS：

> [p422 代码片断二]

我们需要明确一件事情，对于浏览器而言，因为最终输出是标准CSS，预处理器不会向语言添加任何新特性。但对于作为开发者的我们来讲，预处理器确实提供了许多方便。

在前面的例子中，使用变量代表颜色值，就可以多次重复使用它，而不需要每次复制粘贴十六进制码。生成输出文件的过程中，预处理器替我们做了重复复制这件事情。这也意味着我们可以在一个地方修改变量值，改动会传递到整个样式表。

预处理器有好几种，其中比较流行的两个是`Sass`（[https://sass-lang.com/](https://sass-lang.com/)）和`Less`（[http://lesscss.org/](http://lesscss.org/)）。Sass是最常见的预处理器，接下来我们会占用较多的篇幅来介绍它。Less和Sass其实比较类似，主要在一些语法细节上有所区别。举例来说，Sass使用$来表示变量（`$brand-blue`），而Less使用@符号（`@brand-blue`）。附录中提到的所有Sass特性，Less都支持，可以浏览Less的官方文档查看语法上的区别。

## B.1 Sass

使用Sass之前，需要先确定几件事情。首先是使用哪种实现方案。Sass是用Ruby写的，但这种实现方式在编译大型样式表的时候比较慢，所以建议使用`LibSass`，这是用C/C++实现的Sass编译器。

如果你对JavaScript和Node环境比较熟悉，可以通过npm包管理工具安装node-sass，也可以获取LibSass。如果还没有安装Node.js，可以在[https://nodejs.org](https://nodejs.org)上找到它（免费），按照上面的指导进行下载安装即可。后面会介绍相关的操作命令，但如果你想了解更多npm或者遇到问题需要求助，可以访问[https://docs.npmjs.com/getting-started/](https://docs.npmjs.com/getting-started/)。

### B.1.1 安装Sass

要安装Sass，先在终端中新建一个项目目录，并进入该目录。然后运行下面两条命令：

- `npm init -y`——初始化一个新的npm项目，创建package.json文件。关于该文件的更多信息可以查看第十章（10.1.1节）。
- `npm install --save-dev node-sass`——安装`node-sass`包，并把它作为开发依赖写入package.json。

> **注意**
>
> 在Windows系统中，还需要安装`node-gyp`包。更多信息可以查看[https://github.com/sass/node-sass#install](https://github.com/sass/node-sass#install)。

第二个需要确认的事情是使用哪种语法。Sass支持两种语法：Sass和SCSS。它们的语言特性是一样的，但Sass语法去掉了所有的花括号和分号，严格使用缩进来表示代码结构。比如：

> [p424 代码片断一]

这有点类似于Ruby和Python这样的编程语言，空格是有意义的。SCSS语法使用花括号和分号，所以看起来更像标准CSS。例如：

> [p424 代码片断二]

相对来讲，使用SCSS更普遍一些。如果你不太确定，建议选择SCSS，我们在这篇附录中也是使用SCSS。

> **注意**
>
> SCSS文件使用.scss扩展名，Sass文件使用.sass扩展名。

### B.1.2 运行Sass

现在已经安装好了Sass，我们开始创建样式表。在项目目录新建两个子文件夹，分别叫做sass和build。我们会把源文件放在sass文件夹，Sass会使用这些文件来生成CSS文件，并放到build文件夹。接下来，编辑package.json文件。按照下面的代码清单修改`scripts`入口。

**清单B.1 为package.json添加一条sass命令**

> [p424 代码清单一]

这样就定义了一条`sass`命令，运行的时候会把sass/index.scss编译成build/styles.css这个新文件。目前项目中还不存在sass/index.scss文件，先创建它，Sass源码会放在这里面。运行`npm run sass`，执行这条命令，就会生成（或者覆盖）build/styles.css样式表。

> **小贴士**
>
> 像Grunt、Gulp和Webpack这些常见的任务构建工具，都会有一些可以使用的插件，比如gulp-sass。如果你想使用插件，可以找一款Sass或者Less的，集成到自己最熟悉的工作流之中。

### B.1.3 理解核心的Sass特性

前面已经展示过Sass变量的例子了（`$brand-blue`）。把下面清单中的代码添加到index.scss文件中，看看Sass是如何编译的。

**清单B.2 Sass变量**

> [p425 代码清单一]
>
> Defines a variable
>
> 定义变量
>
> Uses the variable
>
> 使用变量
>
> Uses the variable
>
> 使用变量

运行`npm run sass`，可以把上面的代码编译成CSS。输出文件（build/styles.css）看起来应该是这样的：

> [p425 代码片断一]

变量已经被替换为十六进制颜色值，浏览器现在可以直接运行了。同时Sass还生成了一个源映射文件，并添加一条注释到样式表的底部，用来标明`源映射`的路径。

> `源映射`（source map）是一个特殊文件，计算机可以用它来追踪生成后的代码（在我们这里是CSS）中每一行对应的源代码中的那一行（Sass）。这个映射文件可以用在一些调试器中，包括浏览器的开发者工具。

你可能注意到编译后的代码没有被很好地格式化，闭合花括号带到了上一行，有时候空行也可能会删除。这些都没关系，因为浏览器是不会关心这些空格的。但我会把附录里接下来的例子中的代码格式处理好，这样结构清晰更易于理解。

**行内计算**

Sass同样支持使用+、-、*、/和%（除法取整）进行行内计算。这样我们就可以从一个初始值获得多个值，如下面清单所示。

> [p425 代码清单二]
>
> [p426 代码清单一]
>
> Uses a variable 使用变量
>
> Multiplies variable by two 变量乘以2

使用`npm run sass`编译源码，生成了下面的输出：

> [p426 代码片断一]

这个特性在两个值相关但不同的时候特别有用。在例子中，无论`$padding-left`的值是多少，`note-body`的左侧内边距总是`note-author`的两倍。

**嵌套选择器**

Sass允许在代码块内嵌套选择器。你可以使用嵌套把有关联的代码分到一组，如下所示。

> [p426 代码清单二]
>
> Nested selector
>
> 嵌套的选择器
>
> Ampersand indicates where the outer selector will be appended.
>
> &符号代表外层选择器将被插入的位置

Sass会把外层代码块的选择器与嵌套选择器合并。示例代码会被编译为：

> [p426 代码片断二]

默认情况下，外层的`.site-nav`选择器会自动添加到编译代码的每个选择器前面，拼接的位置还会插入一个空格。要修改默认操作，可以使用&符号代表外层选择器想要插入的位置。

> **警告**
>
> 嵌套会提升最终生成的选择器的优先级，使用嵌套的时候要小心，避免嵌套层级过深。

也可以在代码块内嵌套媒体查询，这样可以用来避免重复书写相同的选择器，就像下面清单展示的这样。

**清单B.5 嵌套媒体查询**

> [p427 代码清单一]
>
> Media query inside a declaration block
>
> 代码块内的媒体查询

这段代码将会编译成：

> [p427 代码片断一]

这样的话，如果你要修改选择器，就不必再去媒体查询里面修改对应的选择器了。

**局部文件（partials）**

局部文件可以允许你把样式分割成多个独立的文件，Sass会把这些文件拼接在一起生成一个文件。使用局部文件可以按照自己的想法随意组织文件，但最终只提供给浏览器一个文件，这样可以减少网络请求的数量。

在项目中新建sass/button.scss文件，添加下列样式到文件中。

**清单B.6 按钮局部样式表**

> [p427 代码清单二]

然后在`index.scss`中使用`@import`规则引入这个局部样式表，写法如下：

**清单B.7 引入局部文件**

> [p428 代码清单一]
>
> Path to the partial file
>
> 局部文件的路径

运行Sass的时候，局部文件会被编译，然后插入到`@import`规则指定的地方。

我认为这是预处理器最重要的特性。随着样式表体积越来越大，滚动上千行代码去寻找样式表中相关的部分变得非常困难。使用这个特性可以把样式表打散，变成一系列小巧的模块，同时又不会带来网络性能开销。想要了解更多，可以查看第九章的“预处理器与模块化CSS”补充内容。

**混入（mixins）**

`混入`是一小段CSS代码块，可以在样式表任意地方复用。如果有一段特定的字体样式需要在多个地方使用，或者类似清除浮动这样常用的重复规则（第四章4.2节讨论过），使用混入就比较合适。

混入使用`@mixin`来定义，使用`@include`来调用。这里有个清除浮动的混入使用案例。

**清单B.8 清除浮动混入**

> [p428 代码清单二]
>
> Defines a mixin named clearfix
>
> 定义一个混入，命名为clearfix
>
> Nested selectors
>
> 嵌套选择器
>
> Applies the mixin
>
> 调用混入

预处理器会提取mixin中的代码，替换到`@include`规则所在的位置。最终的代码看起来是这样的：

> [p428 代码片断一]
>
> [p429 代码片断一]

注意，最终编译生成的代码中没有了clearfix。混入的内容只会添加到样式表中用到了它的地方。

你还可以定义带参数的混入，就像平时编程中使用的函数一样。下面的清单中展示的混入，定义了一个警告框。其中有两个参数`$color`和`$bg-color`，它们是混入的作用域内定义的变量。

**清单B.9 带参数的混入**

> [p429 代码清单一]
>
> Defines a mixin with two parameters
>
> 定义一个包含两个参数的混入
>
> Parameter variables can be used within the mixin.
>
> 参数变量可以在混入中使用
>
> Passes values into the mixin
>
> 把值传到混入中

每次调用混入，都可以传递不同的值。这些值指定为对应的变量。上面的这段代码最终输出的CSS如下：

> [p429 代码片断二]

混入又一次实现了复用同一段代码，但在这种情况下，最终生成了两个不同的版本。生成的代码不同，是因为传递的参数值不一样。

> **警告**
>
> 在过去，混入特性经常用来为某些CSS属性混入带前缀的写法。例如，`border-radius`混入可能代表`-webkit-border-radius`、`-moz-border-radius`和`border-radius`三个属性。我不太建议你这么使用混入特性，可以考虑使用Autoprefixer来代替（想了解更多内容，可以查看本节附录后面的“PostCSS”部分）。

**扩展（extend）**

sass还支持`@extend`规则。这和mixin有点类似，但编译方式有所不同。对于扩展，sass不会多次复制相同的声明，而是把选择器聚合在一起，这样它们就会包含同样的规则。最好还是通过示例来演示。在下面的清单中，`.message`包含的规则被扩展到另外两个规则集合中。

**清单B.10 扩展基础类**

> [p430 代码清单一]
>
> Shares styles with the .message class
>
> 和.message类共享样式

上面的代码会生成下面的输出：

> [p430 代码片断一]

注意，Sass复制了`.message-info`和`.message-danger`选择器，并上移到第一个规则集。这样做的好处是标签只需要引用一个类，无需两个都引入，从`<div class="message message-info">`变成了`<div class="message-info">`。因为现在`message-info`类也包含`message`类中所有的样式，再引入`message`类就变得多余。

> **警告**
>
> `@extend`不同于mixin，它会把选择器移动到样式表中更靠前的位置。这就意味着我们写的代码最终的顺序可能跟期望的不完全相同，就会影响样式叠加的结果。

`@extend`的输出长度通常会比mixin短一些。这是显而易见的，也很容易想到`@extend`更好一些，因为它最终输出的样式表体积更小（因此网络传输速度更快）。但也要知道mixin产生的大量重复代码，使用gzip可以压缩成比较小的体积。只要你的服务器使用gzip压缩处理过所有的网络传输（当然，也应该这么做），增加的这些重复代码通常会比预想的小得多。

但也不要为了性能优化就完全放弃mixin，只用`@extend`。要思考代码的组织方式，具体问题具体分析，看看mixin和extend哪种更合适一些。通常情况下，你可能更倾向于使用mixin，只有当你需要减少HTML中填写的类名数量的时候才考虑使用`@extend`，就像清单B.10那样。

**颜色处理**

Sass还有个不错的特性，它有一堆处理颜色的函数。如果你需要两个同类的颜色（比如，同一种绿色的较浅和较深版本），可以使用下面清单中的函数来生成。

> **清单B.11 Sass颜色函数**
>
> Darkens by 10%
>
> 加深10%
>
> Lightens by 10%
>
> 减淡10%
>
> Adjusts color saturation
>
> 调整饱和度
>
> Rotates hue around the color wheel
>
> 在色相环上旋转颜色
>
> Adjusts transparency
>
> 调整透明度

通过这些函数，你可以实现修改一个变量，同时修改相关联的其他颜色值。这样就不必把所有颜色都存到变量中，可以在用到的属性中直接修改：

> [p431 代码片断一]

如果你需要实现更多高级操作，还有一些其他的颜色函数，可以参考[http://jackiebalzer.com/color](http://jackiebalzer.com/color)。

**循环**

针对某个值使用循环，可以生成一系列细小的变化。在第15章中，我们使用了几个`:nth-child()`选择器来指定连续的菜单元素，然后为每个元素添加不同的`transition-delay`（清单15.10）。这类代码可以更简单地使用Sass循环来实现，会用到`@for`规则，就像下面的清单展示的这样。

**清单B.12 遍历一组值**

> [p432 代码清单一]
>
> Iterates the $index value from 2 to 4
>
> 从2到4迭代$index值
>
> Uses the variable in the selector
>
> 在选择器中使用变量
>
> Multiplies the variable by a time value
>
> 变量乘以一个时间值

这样就把相同的代码块输出了好几次，每次变量`$index`的值都会增加。我们在选择器中使用了该变量，是通过`#{}`标记来输出的。最终代码看起来是这样的：

> [p432 代码片断一]

在原生CSS中，修改这种模式的代码比较麻烦。如果我要把过渡延迟改成每次增加0.15秒，就需要分别手动把每个声明改成0.15s、0.3s和0.45s。如果我想再添加一个重复动作，就需要手动复制代码块并修改所有值。现在有了Sass循环，要做修改，只需要编辑数学公式或者修改迭代次数。

**它还是CSS**

预处理器不会修改CSS的基本原理。我们在整本书中讲到的内容，依然全部适用。之所以没有贯穿全书地使用Sass，是因为我希望书中所有话题讲解的都是这门语言本身的知识要点，而不是任何一款预处理器。即使你要使用Sass，也依然需要深入理解CSS。但Sass（或者Less）可以完成原生CSS中绝大部分比较耗时的工作。Sass是一个非常有用的工具，强烈建议你学着熟练使用它。

## B.2 PostCSS

PostCSS（[https://postcss.org/](https://postcss.org/)）是另一种类型的预处理器。它编译源文件并输出一个处理过的CSS文件，这一点上和Sass或者Less一样。但PostCSS是完全依靠插件工作的。如果没有安装插件，输出文件就是一份没有任何变化的源文件复制品。

你能用PostCSS实现什么功能，完全取决于你使用哪些插件。你可以使用多个插件，提供和Sass一样的功能；也可以只用一两个插件，同时使用Sass和PostCSS运行代码。如果有需要，你甚至可以用JavaScript编写自己的插件。

有一点很重要，PostCSS运行插件是有顺序的。如果你配置了多个插件，它们的执行顺序有时候影响很大，可能需要反复试验才能使PostCSS实现想要的工作方式。具体的配置方法可以查看PostCSS文档。

> **注意**
>
> PostCSS最开始是指发布处理器（post-processor），因为它通常在预处理器之后运行。PostCSS已经脱离之前那个特定的工作阶段，其字面意思相对于所有工具可以提供的能力范围来讲，是有一些局限的。

### B.2.1 使用Autoprefixer

PostCSS中最重要的插件可能就是Autoprefixer（自动添加前缀）了。这个插件可以将相关的所有浏览器前缀都添加到CSS中。想要了解更多浏览器前缀相关的信息，可以查看第五章中的“浏览器前缀”补充内容。

如果你的源代码是这样的：

> [p433 代码片断一]

Autoprefixer会添加额外的声明，为旧版浏览器提供带前缀的回退写法，输出如下：

> [p433 代码片断二]

如果你要自己手写所有的浏览器前缀，既耗时又容易出错。同时源码中会增加大量的无意义代码，因为不需要过多关注这些带浏览器前缀的CSS如何运行。

你可以为Autoprefixer配置想要支持的浏览器列表，如果有需要，它会自动添加浏览器前缀来支持这些浏览器。例如，使用数组`["ie >= 10", "last 2"]`配置Autoprefixer，可以确保你的代码兼容（如果可行的话）IE10及以上和所有其他浏览器最新的两个版本。Autoprefixer使用[caniuse.com](https://caniuse.com/)数据库中的最新数据来确定什么时候需要添加前缀。

在这里强烈建议你哪怕不用任何其他PostCSS插件，也要用上Autoprefixer。本书全部的代码示例都没有包含浏览器前缀，就是因为我已经假定你会使用Autoprefixer来做这件事情。

### B.2.2 使用cssnext

cssnext（[https://cssnext.github.io/](https://cssnext.github.io/)）是另一款非常流行的PostCSS插件（也可以称之为一组插件）。这款插件希望模拟那些还不被所有浏览器支持的最新的CSS语法（有一些还没有在CSS规范中最终确认），为实现这些CSS特性使用了很多方法，比如polyfill等。

这款插件里的很多特性有点像Sass提供的功能，比如嵌套选择器、使用`@apply`规则实现类似mixin的行为、颜色处理函数等。cssnext中同样也包含Autoprefixer。查看[http://cssnext.io/features/](http://cssnext.io/features/)可以获取插件特性的完整列表。

我们需要知道这些特性中的一部分仍然处在W3C研发的早期阶段，在最终定下来之前，几乎可以确定会做一些修改。如果你想体验这些前瞻性的CSS特性，可以使用cssnext插件，但是不建议你只用这个插件作为唯一的预处理器规则。随着浏览器为一些cssnext特性添加原生支持，从使用PostCSS处理这些特性过渡到使用浏览器原生实现，变得比较困难。有个比较好的办法是把预处理器规则从兼容规则中分离出去。

### B.2.3 使用cssnano

cssnano（[http://cssnano.co/](http://cssnano.co/)）是基于PostCSS的压缩工具。`压缩工具`（minifier）可以从代码中剥离所有无关的空格，使代码体积尽可能变小，但同时依然保持一致的语法含义。

> **注意**
>
> 压缩工具不能代替gzip压缩，gzip是需要服务器来提供的。一般来讲，最好是对CSS同时使用体积压缩和gzip压缩，这样可以减少网络加载时间。

CSS压缩工具有很多种，但相比单独为CSS压缩，作为PostCSS构建过程中的一步显然更有意义。cssnano可以让你这么做。

### B.2.4 使用PreCSS

PreCSS（[https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss)）是一款PostCSS插件包，提供了一些类似Sass的特性。其中包含$变量、行内计算、循环和混入等。

如果你感觉同时使用Sass和PostCSS预处理器运行代码效率有点低，可以考虑使用PostCSS的PreCSS插件包来代替Sass。PreCSS和Sass并不是完全相同，如果你选择这种替代方案，需要查阅PreCSS的文档。这是个相对较新的工具，可能不如Sass稳定（【译者注】截止到译者翻译本节的时候，PreCSS已有10个月未提交新代码，并有二十几个issue未处理，其中大部分是bug反馈。译者建议谨慎用于生产环境）。