# 第15章 变换

> 本章内容
>
> * 使用变换操作元素，提升过渡和动画的性能
> * 为过渡添加“弹跳”效果
> * 浏览器的绘制路径
> * 了解一下3D变换和透视距离



本章我们学习一下`transform`（变换）属性，它可以用来改变页面元素的形状和位置，其中包括二维或者三维的旋转、缩放和倾斜。变换通常结合过渡或动画一起使用，这也是为什么我们把本章内容放在这两个话题之间。在这最后的两章中，你会用到大量的过渡、变换和动画来创建页面。

首先，我们看看如何在静态元素上应用变换。这样就可以理解这些变换行为是怎样独立工作的，便于后面把变换添加到过渡中。然后我们会创建一个稍微复杂的小菜单，用到多种变换和过渡效果。最后再看一下如何使用3D变换和透视图。这部分内容会一直延续到下一章，到时候我们会使用3D变换配合动画一起使用。

## 15.1 旋转、平移、缩放和倾斜

基本的变换规则看起来像下面这样：

`transform: rotate(90deg);`

这条规则应用到元素上之后，会使元素向右（顺时针）旋转90度。变换函数`rotate()`用来指定元素如何变换。还有其他几种不同的变换函数，这些函数通常被分成以下四类（在图15.1中有演示）：

- `旋转`（Rotate）——元素绕着一个轴心转动一定角度
- `平移`（Translate）——元素向上、下、左、右各个方向移动（有点类似相对定位）
- `缩放`（Scale）——缩小或放大元素
- `倾斜`（Skew）——使元素变形，顶边滑向一个方向，底边滑向相反的方向。

**图15.1 四种基本变换类型（虚线框代表元素的初始位置）**

> [p371 图一]

每种变换都使用相应的函数作为`transform`属性的值。下面我们新建一个简单的示例，在浏览器中试一下。这是一张带图文的卡片（图15.2），我们对其使用变换效果。

新建一个页面和一张样式表，把它们关联起来。添加下面清单中的HTML。

**清单15.1 创建一张简单卡片**

> [p371 代码清单一]

**图15.2 应用了旋转变换的简单卡片效果**

> [p372 图一]

接下来在样式表中添加下列清单中的CSS，其中包含了一些基础样式、颜色设置和应用了旋转变换的卡片样式。

**清单15.2 设置卡片样式并使用变换**

> [p372 代码清单一]
>
> Centers the card 使卡片居中
>
> Rotates the card 15 degrees to the right 使卡片向右旋转15度

在浏览器中加载页面，我们就可以看到旋转后的卡片。通过这个小实验，或多或少能感受到`rotate()`函数是怎样工作的。使用负角度可以使卡片向左侧旋转（可以试一下`rotate(-30deg)`）。

接下来可以尝试使用其他函数修改变换类型。使用下面的这些值，并观察它们的行为：

- `skew(20deg)`——使卡片倾斜20度。试试负角度，让卡片向其他方向倾斜。
- `scale(0.5)`——将卡片缩小至原始尺寸的一半。`scale()`函数需要一个无单位的数值，小于1表示要缩小元素，大于1表示要放大元素。
- `translate(20px, 40px)`——使元素向右移动20px，向下移动40px。同样，也可以使用负值使元素向相反的方向变换。

使用变换的时候要注意一件事情，虽然元素可能会被移动到页面上的新位置，但它不会脱离文档流。你可以在屏幕范围内以各种方式平移元素，其原始位置不会被其他元素占用。同样，当旋转某元素的时候，它的一角可能会移出屏幕边缘，也可能会遮住旁边其他元素的部分内容（图15.3）。

**图15.3 变换元素不会导致其他元素移动，所以可能会出现遮挡**

> [p373 图一]

某些情况下，为变换元素或者所有元素设置较大的外边距，有助于避免不必要的遮挡。

> **警告**
>
> 变换不能作用在`<span>`或者`<a>`这样的行内元素。若确实要变换此类元素，要么改变元素的display属性替换掉`inline`（比如`inline-block`），要么把元素改为flex或者grid项目（为父元素应用`display: flex`或者`display: grid`）。

### 15.1.1 更改变换基点

变换是围绕着`基点`（point of origin）发生的。基点是旋转的轴心，也是缩放或者倾斜开始的地方。这就意味着元素的基点是固定在某个位置上，元素的剩余部分围绕基点进行变换（对于`translate()`是个例外，因为平移过程中是元素整体移动的）。

默认情况下，基点就是元素的中心，但可以通过`transform-origin`属性改变基点位置。图15.4展示了一些围绕不同基点变换的元素。

**图15.4 使用元素上不同的角作为基点发生的旋转、缩放和倾斜**

> [p374 图一]
>
> Rotate around bottom right 围绕右下角旋转
>
> Scale around top right 围绕右上角缩放
>
> Skew around top left 围绕左上角倾斜

左侧的元素绕基点旋转，其基点设置为`transform-origin: right bottom`；中间的元素向着基点（`right top`）缩放；右侧元素的倾斜方式是，基点（`left top`）保持不动，元素其他部分向远处延伸。

基点也可以指定为百分比，从元素左上角开始测量。下面的两句声明是等价的：

```
transform-origin: right center;
transform-origin: 100% 50%;
```

> **注意**
>
> 也可以使用px、em或者其他单位的长度值来指定基点。按照我的经验，使用`top`、`right`、`bottom`、`left`和`center`这些关键字，在大部分项目中就够用了。

### 15.1.2 使用多重变换

可以对`transform`属性指定多个值，用空格隔开。变换的每个值将会从右向左按顺序执行。比如我们设置`transform: rotate(15deg) translate(15px, 0)`，元素会先向右平移15px，然后顺时针旋转15度。按照下面清单编辑样式表。

**清单15.3 使用多种变换**

> [p375 代码清单一]
>
> Translates 20 px right, then rotates 15 degrees clockwise 向右平移20px，然后顺时针旋转15度

最简单的查看这种效果的方法就是打开浏览器的开发者工具，实时修改属性值，看它们是如何影响元素的。注意修改`translate()`的值的时候，元素好像是沿着一个倾斜的坐标轴在移动，而不是正常的方向。这是因为旋转发生在平移之后。

理解起来可能有点儿困难。通常把`translate()`放在最后执行（在`transform`代码顺序中需要放在首位），这样操作更简便，可以使用正常的上/下、左/右坐标系。把代码调整为`transform: translate(20px, 0) rotate(15deg)`可以查看具体效果。

## 15.2 在运动中变换

变换本身不具备太多实用性。一个使用了`skew()`的盒子可能看上去很有趣，但并不适于阅读。当和动作结合起来使用的时候，变换就会有用得多了。

下面我们就创建新页面，实践一下这类用法。图15.5展示了将要实现的页面快照，我们接下来会为页面添加很多动作。

本章我们会实现左侧的导航菜单。最初的时候，菜单只有四个纵向排列的图标；鼠标悬浮的时候，菜单文字将会出现。这个实例包含多个过渡和一对变换。接下来我们先实现页面，然后进一步研究导航菜单（下一章中我们会实现中间主区域的卡片部分，并为其添加更多的变换和动画效果）。

新建页面和名为style.css的样式表，添加下列清单中的标记。代码中包含了一个链接，指向Google Fonts API提供的两款web字体（Alfa Slab One和Raleway）。代码中还包括页面的标题和导航菜单。

**图15.5 左侧的导航图标将由多个变换和过渡效果组成**

> [p376 图一]

**清单15.4 演示在运动中过渡的页面使用的标记**

> [p376 代码清单一]
>
> Adds Alfa Slab One and Raleway fonts to the page 为页面添加Alfa Slab One和Raleway两款字体
>
> [p377 代码清单一]
>
> Nav links each contain an image and a label 每个导航链接都包含一张图片和一个标签

`nav`元素包含了这段代码中的大部分内容，其中有个链接的无序列表（`<ul>`）。每个链接都由一个图标图片和一个文本标签组成。注意，这里的图标图片是SVG格式。后面你会发现这很重要，到时候会在下一章为页面添加更多内容。

> SVG——Scalable Vector Graphics的简称，可缩放矢量图形。这是一种基于XML的图片格式，使用向量定义图片。因为图片是使用数学计算来定义的，可以被放大或缩小到任意尺寸。几乎所有的浏览器都支持SVG。

接下来我们添加一些基础样式，包括背景渐变和标题区域的内边距，同时也为页面引入web字体。复制或者添加下面代码清单到样式表。这些只是基础样式和标题部分，菜单部分的布局后面再说。

**清单15.5 基础样式和标题样式**

> [p377 代码清单二]
>
> [p378 代码清单一]
>
> 【译者注：这段代码中body的第一句多了一个background-color:】
>
> Deep blue background gradient 深蓝色背景渐变
>
> Ensures that the body fills the viewport so the gradient fills the screen 确保body元素充满整个视窗，这样渐变就会充满屏幕
>
> Smaller padding for the header on mobile viewports 在移动视窗上为标题区域设置稍小的内边距
>
> Larger padding for the header on larger screens 在较大的屏幕上为标题区域设置稍大的内边距

这个示例用到了前面章节里的很多概念。body元素的背景使用了径向渐变，可以为页面增加一点立体感（Opera Mini浏览器不支持径向渐变，`background-color`为其提供了回退值）。web字体Alfa Slab One作用在标题上，Raleway用在正文主体。页面标题区域通过媒体查询设置了响应样式，屏幕尺寸足够大的时候添加更多的内边距。

要实现菜单需要分成几个步骤。首先完成菜单的布局，然后设置一些响应行为。我们采用移动优先的实现方案（见第8章），从小屏幕开始。标题和菜单看起来应该像图15.6这样。

**图15.6 导航菜单的移动设计**

> [p379 图一]

鉴于小屏幕上导航链接按水平方向排列，考虑使用弹性盒布局比较合适。我们对弹性容器设置`justify-content: space-between`（【译者注：原书中这里写错了，不是align-content，应该是justify-content】），这样导航项目之间可以平均地分配页面宽度。接下来我们设置字体颜色和图标对齐。把下列代码添加到样式表：

**清单15.6 导航菜单链接的移动样式**

> [p379 代码清单一]
>
> Uses a flexbox to spread the nav items across the screen horizontally 使用弹性盒布局在屏幕水平方向上展开导航项
>
> Styles the link text 为链接文本添加样式
>
> Moves icons down slightly to center them with the text labels 把图标向下稍微移动，与文本标签对齐

在小屏幕上菜单就是这样了。但在较大的屏幕上，我们可以添加更多的特效。对于桌面设备，可以使用固定定位使菜单停靠在屏幕左侧，效果看上去如图15.7所示。

这个菜单由两个模块构成，前面已经为外层元素命名为`main-nav`，内层结构命名为`nav-links`。`main-nav`用作容器，固定在左侧。`main-nav`同时还提供了深色背景。下面我们来实现一下。

**图15.7 可视区域较大时，导航菜单停靠在屏幕左侧**

> [p380 图一]

添加下面代码到样式表中，注意第二个媒体查询及其内容要放在已有的`nav-links`（【译者注】原书中这里是main-nav，写错了，应该是nav-links）样式后面，这样才可以在必要的时候覆盖掉移动样式。

**清单15.7 在大屏幕上固定菜单**

> [p380 代码清单一]
>
> Applies styles only to medium and larger screens 仅在大中型屏幕上应用样式
>
> Ensures the nav shows in front of other content added to the page later 确保导航显示在网页后续新增内容的前面
>
> Initially leaves the background color transparent 开始的时候保持背景颜色透明
>
> Adds a transition effect to the background 为背景颜色添加过渡效果
>
> Applies a dark semi-transparent background on hover 为鼠标悬浮状态设置深色半透明背景
>
> Overrides the flexbox from mobile styles to make links stack vertically 覆盖移动样式中的弹性盒布局，使链接纵向排列

`position: fixed`声明把菜单放入并固定在一个位置，页面滚动也不会受到影响。`display: block`规则会覆盖掉移动样式中的`display: flex`，使得菜单项叠放在一起。

接下来我们开始处理过渡和变换效果。需要完成三件事情：

1. 鼠标划过链接的时候，放大图标尺寸；
2. 隐藏链接标签，当用户使用鼠标划过菜单的时候，让它们通过渐显过渡特效全部显示出来；
3. 使用位移为链接标签添加“飞入”效果，与渐显一起使用。

下面我们来一一实现。

### 15.2.1 放大图标

先来看一下导航链接的结构。每个列表元素都包含一个链接(`<a>`)，链接中包含一个图标和一个标签。

> [p381 代码片段一]

> **注意**
>
> 列表元素是要与父元素`<ul>`组合在一起使用的，所以体积会更大一些，比预想中的模块嵌套更深。我有考虑把它们拆分成更小的模块，但眼下需要把它们放在一起，以便整体设置特效。

我们先来实现一下鼠标划上的时候放大图标。需要用到缩放变换，然后添加过渡效果，这样可以使变换过程变得平滑。如图15.8所示，鼠标悬浮在Events菜单元素上，它的日历图标会稍微放大一些。

**图15.8 左侧是正常的图标尺寸，右侧是鼠标悬浮状态下图标放大**

> [p381 图一]

Events的图标设置过宽度和高度，我们可以通过增大这些属性来放大它。但这样会导致周围的其他元素也跟着移动，文档流会重新计算。

如果改用变换，那周围的元素不会受到影响，Events标签也不会向右移动。更新CSS，为悬浮或者激活状态下的元素添加效果。

**清单15.8 链接在鼠标悬浮或者激活状态下，图标会放大**

> [p382 代码清单一]
>
> Transitions the transform property 为transform属性添加过渡
>
> Scales up the icon size 增大图标尺寸

现在，如果你用鼠标划过菜单元素，你将看到相应的图标会变大一些，帮助用户确认正在指向哪个元素。我们特意使用SVG图片资源，这样图片尺寸变化的时候就不会出现像素颗粒或者其他奇怪的失真。`scale()`变换用来实现类似需求真是恰到好处。

> **SVG：一种更好的图标解决方案**
>
> 图标在某些设计中是非常重要的一部分，图标的使用技巧也一直在进化。很长一段时间里，图标使用的最佳实践是把所有图标放入一张单个图片文件，称之为`雪碧图`(sprite)。然后使用CSS背景图片，小心翼翼地调整尺寸和背景位置，在元素中展示雪碧图上的图标。
>
> 后来，`图标字体`(icon fonts)开始流行起来。这种解决方案不再把图标嵌入雪碧图，而是把每个图标都作为字符放入自定义的字体文件。通过使用web字体，单个字符将被绘制成图标。类似Font-Awesome（[http://fontawesome.io/](http://fontawesome.io/)）这样的服务就提供了几百个常见的图标，图标使用变得非常简单。
>
> 以上这些技术依然还在使用，但我还是建议你选择使用SVG图标。SVG功能强大，性能更好。SVG可以作为`<img>`资源使用，本章就这么用过，但SVG还有其他用法。我们可以创建SVG雪碧图，而且因为SVG是基于XML的文件格式，可以直接在HTML中使用它。例如：
>
> [p383 代码片段一]
>
> 如果有需要，也可以直接对SVG的部分中使用CSS。使用正常的CSS就可以动态地改变SVG中不同部分的颜色，甚至改变尺寸和位置。同时SVG的文件体积更小，因为它不同于GIF、PNG这些像素化的图片或者其他基于光栅的图片格式。
>
> 如果你不太熟悉SVG，可以查看[https://css-tricks.com/using-svg/](https://css-tricks.com/using-svg/)，其中介绍了在web页面中使用SVG的多种方式，是个不错的入门资料。

现在图标看上去可以了，我们接下来把注意力转向它们旁边的标签。

### 15.2.2 创建"飞入"的标签

菜单的标签没有必要一直保持可见状态。默认情况下可以把它们隐藏，只在相应位置保留图标，告诉用户菜单的位置。然后当用户移动鼠标到菜单或者导航元素上的时候，再把标签以渐显的方式展示出来。这样的话，用户的鼠标一旦靠近图标，整个菜单就会显现。这个过程中一次性使用了多种特效，背景和标签都使用了渐显，标签从它们最终位置偏左一点开始过渡(如图15.9)。

整个特效中，标签需要同时使用两个不同的过渡效果：一个针对透明度，另一个针对`translate()`变换。参照下面清单中列出的代码，更新样式表中的相应部分。

**图15.9 鼠标浮上的时候，菜单渐显，标签渐显的同时从左侧滑入**

> [p384 图一]

**清单15.9 `导航元素`标签上的过渡**

> [p384 代码清单一]
>
> Makes the label an inline-block so transforms can be applied to it 把标签设置为行内块级元素，这样就可以对其使用变换效果了
>
> Hides the label initially 开始的时候隐藏标签
>
> Shifts the label 1 em to the left 使标签向左移动1em
>
> Adds transitions to the values that will change 为要改变的属性值添加过渡
>
> On hover or focus, makes the label visible and shifts it back to its correct position 鼠标悬浮或者激活状态下，设置标签可见，并把它移动回正确的位置

菜单只占了屏幕的一小部分，但是操作一下就会发现实际上有很多内容。有些这类的菜单选择器相当长，并且很复杂。

注意，我们刚刚是把`:hover`伪类添加在了顶层的`nav-links`元素上，`:focus`伪类是加到了内部的`<a>`元素上（focus一般只能应用于链接或者按钮等特定元素）。这样所有标签就可以在鼠标划入的时候都显示出来。除此之外，如果用户使用键盘上的Tab健，被激活的单个标签也会显示出来。

隐藏状态下，标签使用`translate()`向左移动了1em。然后在渐显的时候，它会过渡回实际位置。这里的`translate()`函数省略了第二个参数，只指定了x值，这样就只发生水平位移。因为我们不需要元素上下移动，所以这没问题。

自定义的`cubic-bezier()`函数也值得拎出来看一下。它产生了一个弹跳特效：标签向右移动时，超出了停止位置，然后再回到最终位置停下来。图15.10描述了运动曲线：

**图15.10 在终点添加弹跳特效的贝塞尔曲线**

> [p385 图一]

你会发现曲线超出了盒子的顶端，这就意味着value超过了过渡的最终值。从`translate(-1em)`到`translate(0)`的过渡中，标签的变换会短暂地到达一个超出最终位置大概0.15em的值，然后再缓动回到最终位置。与其类似，我们也可以在时序函数的开始添加弹跳效果，即把第一个控制柄移动到低于盒子底部。但是过渡曲线是不可能超出左右两侧边缘的，这不合逻辑。

在浏览器中加载页面，查看过渡是如何运行的。弹跳过程是一闪而过的，你可能需要调慢过渡时间来更好地观察它，这样看上去像是增加了标签的重量和动力，运动过程显得更自然。

### 15.2.3 交错显示过渡

现在的菜单看上去已经非常好了，我们最后再做一次优化，让它更加完美。我们会用到`transition-delay`属性，为每个菜单元素设置不同的延迟时间。这样就可以使每段动画交错飞入显示，不再一次性全部展示出来，就像翻滚的"波浪"（图15.11）。

**图15.11 顶部的菜单元素将会早于下面的元素飞入**

> [p386 图一]

要实现这种效果，我们将使用`:nth-child()`伪类选择器，根据每个菜单元素在列表中的位置找到它们，然后分别为每个元素设置连续变长的过渡延迟。把下列清单中的代码添加到样式表中，放在其他`nav-links`样式后面。

**清单15.10 为菜单元素添加错杂排列的过渡延迟**

> [p386 代码清单一]
>
> Targets the second menu item label 选中第二个菜单元素的标签
>
> Delays its transition by one tenth of a second 为过渡设置0.1秒的延迟
>
> Targets the third menu item label 选中第三个菜单元素的标签
>
> Delays its transition by two tenths of a second 为过渡设置0.2秒的延迟
>
> Repeat as many times as needed 视需求情况重复设置

`:nth-child(2)`选择器将会选中列表中的第二个元素，然后为其添加轻微延迟。第三个元素(`:nth-child(3)`)设置了稍长一点的延迟，第四和第五分别再长一点。我们不需要为第一个元素操心，因为我们希望它的过渡立即执行，不需要设置过渡延迟。

在浏览器中运行页面，使用鼠标划过菜单查看效果。整个菜单显得流畅生动。鼠标移开的时候，所有元素以同样的交错顺序渐渐消失。

你会发现这种实现方式有个缺点，那就是菜单必须和所写的选择器数量一样多。我们这里针对第五个元素也添加了规则，虽然当前菜单只有四个元素。这是一种预防措施，以防将来会再增加一个菜单元素。安全起见我们甚至可以为第六个元素添加规则，但你需要意识到菜单数量总是有可能在某个时间点超出已有规则的，记得到时候在CSS中添加更多的规则。

> **小贴士**
>
> 类似的重复代码块，使用预处理器书写会更简单一些，可以查看附录B中的示例。

菜单到现在终于做好了，接下来可以为页面添加更多内容。不过我们先放一放，到下一章再继续实现。在这之前，还有两件和变换有关的事情需要了解。

## 15.3 动画性能

有些变换看上去好像没有存在的必要。比如位移变换的结果，通常也可以使用相对定位来实现；对图片或者SVG做缩放变换，其实也可以通过设置宽高来完成，甚至这样更直观。

实际上，变换在浏览器中的性能要好得多。如果我们要对元素的定位使用动画（比如为`left`属性添加过渡效果），可以明显感受到性能很差。对复杂元素使用动画或者在页面内一次性对多个元素使用动画，问题尤其明显。这种性能问题在过渡（详见第14章）和动画（animation，下一章即将介绍）上都有体现。

如果我们要实现过渡或动画，无论什么类型，包括定位或者尺寸操作，都应该尽可能考虑使用变换。要理解为什么需要这样做，我们需要先看看浏览器是如何绘制页面的。

### 15.3.1 渲染路径

浏览器计算好了页面上哪个元素应用哪些样式之后，需要把这些样式转化成屏幕上的像素点，这个过程叫做`渲染`(rending)。渲染可以分为三个阶段：布局(layout)、绘制(paint)和合成(composite)。

**图15.12 渲染路径上的三个阶段**

> [p387 图一]

**布局**

在第一个阶段`布局`中，浏览器需要计算每个元素即将占据屏幕上的多大空间。受文档流的工作机制所限，一个元素的大小和位置可能会影响页面上其他元素的大小和位置，并且没办法确定会影响到哪些。这个阶段就是要解决这个问题。

任何时候改变一个元素的宽度或高度，或者调整位置属性(比如`top`或者`left`)，元素的布局都会重新计算。如果使用JavaScript在DOM中插入或者移除元素，也会重新计算布局。一旦布局发生改变，浏览器就会`重排`（reflow）页面，重新计算所有其他被移动或者缩放的元素的布局。

**绘制**

布局之后是`绘制`。这个过程就是填充像素点：文本将被描绘，图片、边框和阴影会被着色。这时候不会真正显示在屏幕上，而是在内存中绘制。页面各部分生成了很多的`图层`(layers)。

如果改变某个元素的背景颜色，它会被重新绘制。但更改背景颜色不会影响到页面上任何元素的位置和大小，所以这种变化不需要重新计算布局。改变背景颜色比改变元素尺寸需要的计算操作要少一些。

某些条件下，页面元素会被提取到自己的图层。这时候，它会从页面的其他图层中独立出来单独绘制。浏览器把这个图层发送到计算机的GPU（graphics processing
unit，图形处理器）进行绘制，而不是像主图层那样使用主CPU绘制。这样安排是有好处的，因为GPU经过了充分的优化，比较适合做这类计算。

这就是我们经常提到的`硬件加速`(hardware acceleration)，因为需要依赖计算机上的某些硬件来推进渲染速度。多个图层就意味着需要消耗更多的内存，但好处是可以加快渲染的处理时间。

**合成**

在`合成`阶段，浏览器收集所有绘制完成的图层，把它们提取为最终显示在屏幕上的图像。合成过程需要按照特定顺序进行，以确保图层出现重叠的时候，正确的图层显示在其他图层之上。

`opacity`和`transform`这两个属性如果发生改变，需要的渲染时间非常少。当我们修改元素的这两个属性之一的时候，浏览器会把元素提升到单独的绘制图层并使用GPU加速。因为元素存在于自己独立的图层，整个图像变化过程中主图层将不会发生变化，也不会引入重复的重绘。

如果只是对页面做一次性修改，通常不会感觉出这种优化可以带来明显的差异。但如果修改的是动画的一部分，屏幕需要在一秒内发生多达几十次的更新，这种情况下渲染速度就很重要了。大部分的屏幕每秒钟会刷新60次。理想情况下，动画中每次变化所需的重新计算也要至少这么快，才能在屏幕上生成最流畅的运动轨迹。浏览器在每次重新计算的时候需要做的事情越多，越难达到这种速度。

> **使用`will-change`控制绘制图层**
>
> 浏览器会尽可能把一些元素划归不同的图层，这已经在优化渲染流程上取得了明显的进步。如果你对一个元素的`transform`或者`opacity`属性设置动画，现代浏览器为了使动画过程更加流畅，通常会基于一系列因素做出最佳处理，其中也包含系统资源。但有时候你可能会遇到突变或闪烁的动画。
>
> 如果碰到这种情况，你可以使用一个叫做`will-change`的属性对渲染图层添加控制。这个属性可以提前告知浏览器，元素的特定属性将会改变。这通常意味着元素将被提升到自己单独的绘制层。例如，设置了`will-change: transform`就表示我们将要改变元素的`transform`属性。
>
> 除非遇到性能问题，否则不要盲目添加该属性到页面，因为它会占用更多的系统资源。前后测试一下，在性能表现更好的时候再在样式表中保留`will-change`。如果想要更加深入了解该属性如何工作和是否应该使用它，可以查看这篇来自Sara Soueidan的优秀文章[https://dev.opera.com/articles/css-will-change-property/](https://dev.opera.com/articles/css-will-change-property/)。
>
> 我发现这篇文章发表之后有件事情发生了变化，文中表示只有3D变换会提升元素到单独的图层，现在已经不是这样了，最新的浏览器对2D变换也可以使用GPU加速。

下一章中我们将会看到，处理过渡或者动画的时候，尽量只改变`transform`和`opacity`属性。如果有需要，可以修改那些只导致重绘而不会重新布局的属性。只有在没有其他替代方案的时候，再去修改那些影响布局的属性，并且密切关注动画中是否存在性能问题。如果想要查看哪些属性会导致布局、绘制或者合成，可以查看[https://csstriggers.com/](https://csstriggers.com/)。

## 15.4 三维（3D）变换

目前为止我们使用过的变换都是2D的。这些变换比较容易使用(也比较常见)，因为网页本身就是2D的。但我们不应该被局限在这里，旋转和平移都可以在三个维度上实现：X轴、Y轴和Z轴。

我们可以像之前那样使用`translate()`函数，在水平和垂直方向上平移(X轴和Y轴)。也可以使用`translateX()`和`translateY()`函数实现同样的效果。下面两条声明将会产生同样的结果：

```
transform: translate(15px, 50px);
transform: translateX(15px) translateY(50px);
```

我们同样可以使用`translateZ()`函数实现Z轴上的平移，相当于移动元素使其更靠近还是远离用户。类似地，也可以使元素绕着三个不同维度的坐标轴进行旋转。但和平移不同的是，我们已经非常熟悉`rotateZ()`了，因为`rotate()`就可以称之为`rotateZ()`，它就是绕着Z轴旋转的。函数`rotateX()`和`rotateY()`分别围绕着水平方向上的X轴（使元素向前或者向后倾斜）和垂直方向上的Y轴（使元素向左或者向右转动或偏移）旋转。可以观察一下图15.13中对这些函数的演示。

**图15.13 使用300px透视距离观察三个不同坐标轴上的旋转（虚线框代表元素的原始位置）**

> [p390 图一]

### 15.4.1 控制透视距离

为页面添加3D变换之前，我们需要先确定一件事情，即`perspective`(透视距离)。变换后的元素一起构成了一个3D场景。接着浏览器会计算这个3D场景的2D图像，并渲染到屏幕上。我们可以把perspective想象成"摄像机"和场景之间的距离，前后移动镜头就会改变整个场景最终显示到图像上的方式。

如果镜头比较近（即透视距离小），那么3D效果就会比较强。如果镜头比较远（即透视距离大），那么3D效果就相对不太明显。图15.14展示了几种不同的透视距离。

**图15.14 不同透视距离下相同的旋转**

> [p390 图二]

左侧这个旋转后的元素，没有设置透视距离，看起来不太像是3D的。它只是水平方向上做了一些压缩，没有立体感。不设置透视距离的3D变换看上去像是平的，"向远处转"的那部分元素没有显得变小。再看一下中间这个盒子，设置了400px的透视距离。它的右侧边，即距离观察者较远的这一侧，显得有点变小，距离较近的这一侧看上去变大了一些。右侧盒子设置了更短的透视距离，是100px。这样加强了3D效果，元素的边缘越远，缩小得越明显。

可以通过两种方式指定透视距离：使用`perspective()`变换或者使用`perspective`属性。两种方式有些不同，我们通过一个简单的例子来说明。这是个简化的示例，只是用来演示透视距离的效果。

首先，我们为四个元素添加旋转效果，使用`rotateX()`让它们向后倾斜(图15.15)。每个元素旋转同样的角度，并且设置了相同的`perspective()`，所以它们看上去是一样的。

**图15.15 四个元素都围绕X轴旋转，并且都设置了`perspective(200px)`**

> [p391 图一]

为这个demo新建一个页面，并复制下面的HTML。

**清单15.11 用来演示3D变换和透视距离的4个盒子**

> [p391 代码清单一]

接下来，我们为每个盒子添加3D变换和透视距离。同时我们也可以为盒子填充一些颜色和内边距，使最终效果更加明显。把下面清单中的代码添加到页面的样式表中。

**清单15.12 为盒子添加3D变换**

> [p391 代码清单二]
>
> Rotates the box back 30 degrees and applies a perspective 使盒子向后旋转30度，并设置透视距离

在当前示例中，每个盒子看上去都是相同的。它们都有自己的透视距离，是用`perspective()`函数设置的。这个方法可以为单个元素设置透视距离，示例中我们直接为所有盒子做了相同的配置。这样就像为每个元素分别单独拍照，但是拍摄位置是一样的。

有时候我们希望多个元素共享同一套透视距离，就仿佛它们处于相同的3D空间中。图15.16用来演示这种情况。这里有四个相同的元素，但它们都向着远方的一个相同的交汇点延伸，就仿佛把四个元素放一起然后拍摄一张整体的照片。要实现这种效果，需要为它们的父元素设置`perspective`属性。

**图15.16 为共有祖先元素设置`perspective`属性可以使多个元素共享相同的透视距离**

> [p392 图一]

要查看这样的效果，可以移除盒子上的`perspective()`函数，改成为容器添加`perspective`属性。参考下面清单中的代码。

**清单15.13 建立统一的透视距离**

> [p392 代码清单一]
>
> Adds the perspective to the container 为容器添加透视距离
>
> Don’t apply a perspective transform to the boxes 不再为盒子本身设置透视变换

通过为父容器（或其他祖先元素）设置统一的透视距离，父容器包含的所有应用了3D变换的子元素，都将共享相同的透视距离。

添加透视距离是3D变换中非常重要的部分。如果不设置透视距离，离得远的元素不会显得变小，离得近的元素也不会变大。上面的例子比较小，下一节会把这些技术用在一个实战案例中，实现元素从远处"飞入"页面。

### 15.4.2 实现高级3D变换

对元素进行3D处理的时候，还有其他一些很有用的属性。我们不会占用太多篇幅讲解这些属性，因为在实际开发中用到的机会比较少。下面我们来了解一下这些属性，万一用到也会有些帮助。如果你想更深入研究这些属性，我们也会提供一些在线的示例。

**perspective-origin属性**

默认情况下，透视距离的渲染是假设观察者（或者镜头）位于元素中心的正前方。`perspective-origin`属性可以上下、左右移动镜头的位置。图15.17展示的还是之前的例子，但镜头移到了左下方。

**图15.17 移动透视源点会增大元素向远端延伸的形变**

> [p393 图一]

添加下面清单中的代码，就可以查看效果。

**清单15.14 使用`perspective-origin`移动镜头的位置**

> [p393 代码清单一]
>
> Moves camera position to the element’s bottom left 把镜头位置移动到元素的左下方

还是跟之前一样的透视距离，但是视角变了，所有的盒子都移到了观察者的右侧。我们可以使用关键字`top`、`left`、`bottom`、`right`和`center`来指定位置，也可以使用百分比或者长度值，从元素的左上角开始计算（比如`perspective-origin: 25% 25%`）。

**backface-visibility属性**

如果你使用`rotateX()`或者`rotateY()`旋转元素超过90度，会发现一些有趣的事情：元素的"脸"不再直接朝向你。它的"脸"转向别的地方，你会看到元素的背面。图15.18中的元素设置了`rotateY(180deg)`的变换，它看起来就像是之前元素的镜像图片。

这就是元素的背面。默认情况下背面是可见的，但我们可以为元素设置`backface-visibility: hidden`来改变它。添加这条声明之后，元素只有在正面朝向观察者的时候才可见，朝向别处的时候不可见。

**图15.18 旋转元素查看它的背面**

> [p394 图一]

针对这项技术，一个可能的应用场景是把两个元素背靠背放在一起，就像卡片的两面。卡片的正面展示出来，背面隐藏。然后我们可以旋转它们的容器元素，使这两个元素都翻转过来，这样正面隐藏背面显现。可以查看这篇文章[https://desandro.github.io/3dtransforms/docs/card-flip.html](https://desandro.github.io/3dtransforms/docs/card-flip.html)，里面有卡片翻转特效的demo。

**transform-style（preserve-3d）属性**

如果你要使用嵌套元素构建复杂的3D场景，`transform-style`属性就会变得非常重要。现在假设我们已经对容器设置了透视距离，接下来对容器内的元素进行3D变换。容器元素渲染的时候实际上会被绘制成2D场景，就像是3D对象的一张照片。这看起来没什么问题，因为元素最终就是要绘制到2D屏幕上的。

如果接下来我们对容器元素进行3D旋转，就有问题了。因为实际上没有对整个场景进行旋转，只是旋转3D场景的2D照片。透视距离全都错了，场景中的立体感也变得支离破碎。图15.19中的例子演示了这个问题。

**图15.19 如果对3D变换元素的父元素再做3D变换，可能需要用到`preserve-3d`属性（右侧示例）**

> [p395 图一]
>
> 3D cube looking straight on 3D立方体正面视角
>
> Rotating cube with `flat` transform style 使用flat变换样式旋转立方体
>
> Rotating cube with `preserve-3d` transform style 使用preserve-3d变换样式旋转立方体

左边的图片演示了通过把六个面变换到相应位置创建一个3D立方体。中间的图片展示的是对整个立方体（即它们的父元素）使用变换将会发生什么。为了修正这个问题，我们应该对父元素使用`transform-style: preserve-3d`（如右侧图片所示）。

> **警告**
>
> `preserve-3d`变换样式在所有IE浏览器中都是不支持的。

如果想要了解更多内容和使用案例，可以查看Ana Tudor写的教程[https://davidwalsh.name/3d-transforms](https://davidwalsh.name/3d-transforms)。虽然这些示例很有意思，但我从来没有在实际项目中使用过`preserve-3d`。如果你接触3D变换只是为了看看可以实现哪些东西，这份教程会很有帮助的。

### 总结

- 在二维和三维空间中使用变换来缩放、旋转、平移和倾斜元素；
- 如果想要优化过渡和动画性能，变换是必不可少的；
- 理解渲染路径是如何工作的，创建动画的时候一定要牢记；
- 使用自定义时序函数曲线为过渡添加弹跳特效。

