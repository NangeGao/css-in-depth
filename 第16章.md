# 第16章 动画

> **本章内容**
>
> - 使用关键帧动画为页面添加复杂运动
> - 页面加载的时候使用动画
> - 使用旋转器动画提供反馈
> - 吸引用户对保存按钮的注意力，提醒用户去保存

在前面两章里，我们创建了几种过渡行为，可以使元素从某种状态平滑变换为另一种。这为为页面带来了动态的效果，用户体验上也增加了视觉趣味性。但有时候仅仅使用过渡还不够。

过渡是直接从一个地方变换到另一个地方，相比之下，我们可能希望某个元素的变化过程是迂回的路线。有的情况下，我们可能需要元素产生动画运动之后再回到起始的地方。这些事情没办法使用过渡来实现。为了对页面变化有更加精确的控制，CSS提供了关键帧动画。

`关键帧`（keyframe）是指动画过程中某个特定时刻。我们定义一些关键帧，浏览器负责填充或者插入这些关键帧之间的帧图像（图16.1）。

**图16.1 定义关键帧之后，浏览器插入所有关键帧之间的帧图像**

> [p397 图一]
>
> Interpolated frames 插入的帧图像

从原理上看，过渡其实和关键帧动画类似：我们定义第一帧（起始点）和最后一帧（结束点），浏览器计算所有中间值，使得元素可以在这些值之间平滑变换。但使用关键帧动画，我们就不再局限于只能定义两个点，而是想加多少加多少。浏览器负责填充一个个点与点之间的值，直到最后一个关键帧，最终生成一系列无缝衔接的过渡。

在这最后一章，我们将会介绍如何创建关键帧动画。我们会在前一章创建的页面中添加一些动画，然后探索一些其他的使用方式。动画并非只能做一些让页面变得生动的事情，还能向用户传达一些有意义的反馈。

## 16.1 关键帧

CSS中的动画包括两部分：用来定义一组动画的`@keyframes`规则和为元素添加动画的`animation`属性。

下面我们创建一个简单的动画来熟悉一下语法。动画包含三个关键帧，如图16.2所示。第一帧中元素是红色的；第二帧中元素是浅蓝色，并且向右移动了100px；最后一帧中，元素是淡紫色，并且回到了左侧的初始位置。

**图16.2 三个关键帧，分别对元素的颜色和位置添加动画**

> [p397 图二]

动画对`background-color`和`transform`这两个属性做了一些改动。关键帧规则已经列到了下面的清单中，新建样式表styles.css并添加这些代码。

**清单16.1 定义关键帧规则**

> [p397 代码清单一]
>
> [p398 代码清单一]
>
> Names the animation 为动画命名
>
> First keyframe declarations 第一个关键帧声明
>
> Second keyframe occurs halfway through the animation 第二个关键帧发生于动画进行到一半的时候
>
> Final keyframe 最后一个关键帧

关键帧动画都需要名字，示例中的动画被命名为`over-and-back`。动画中使用百分比定义了三个关键帧。这些百分比代表每个关键帧发生于动画过程中的哪个时刻：一个在动画的开始（0%），一个在中间（50%），一个在终点（100%）。每个关键帧块内的声明定义了当前关键帧的样式。

示例中同时为两个属性添加了动画，但我们注意到并不是每个关键帧都设置了两个属性。transform把元素从初始位置移动到右侧，然后再移回原位。但background-color在50%的关键帧中并没有指定。这意味着元素将会从红色（0%的位置）过渡到淡紫色（100%的位置）。在50%的位置，背景颜色恰好是这两个颜色的中间值。

下面我们把这些代码添加到网页中查看工作情况。新建一个HTML文档并添加下列代码。

**清单16.2 只有一个盒子元素的网页，为盒子添加动画**

> [p398 代码清单二]
>
> The element you’ll animate 即将添加动画的元素

接下来在样式表中为盒子添加样式并应用动画，可以复制下面清单中的代码。

**清单16.3 为盒子应用动画**

> [p398 代码清单三]
>
> Gives the element a height and width for demo purposes 为元素添加宽高以便于演示
>
> Applies the animation to the element 为元素应用动画

在浏览器中打开网页，你会看到动画重复执行了三次，然后停下。`animation`属性是好几个属性的简写。在这个demo中，我们实际上指定了四个属性：

- `animation-name`（`over-and-back`）——代表动画名称，就像`@keyframes`规则定义的那样。
- `animation-duration`（`1.5s`）——代表动画持续时间，在本例中是1.5秒。
- `animation-timing-function`（`linear`）——代表时序函数，用来描述动画如何加速和（或）减速。可以是贝塞尔曲线或者关键字值，就像过渡使用的时序函数一样（`ease-in`、`ease-out`等等）。
- `animation-iteration-count`（`3`）——代表动画重复的次数。缺省的时候，默认值是`1`。

刷新页面，再次查看动画播放，观察动画执行过程中的几个地方：

第一，颜色从0%的红色平滑过渡到100%的淡紫色，但是接下来动画重复的时候立即变回红色。如果你打算重复某个动画并希望整体衔接流畅，需要确保结束值和初始值相匹配。

第二，最后一次重复动画结束之后，背景颜色变为绿色，即原样式规则中指定的值。但要注意动画持续过程中，这句样式声明被`@keyframes`中的规则覆盖了。如果出现样式层叠，动画中设置的规则比其他声明拥有更高的优先级。

我们回顾一下第一章（第1.1.1节），层叠的第一部分是介绍样式表的来源。作者样式优先级高于用户代理样式，因为作者样式有比较高的优先级来源。但动画中应用的声明有更高的优先级来源。为某个属性添加动画的时候，会覆盖样式表中其他地方应用的样式。这就确保了关键帧中所有的声明可以互相配合完成动画，而不用关注动画之外对这个元素可能应用了哪些样式。

> **警告**
>
> 浏览器对动画的支持情况比较好，仅有小部分手机浏览器需要使用`-webkit-`前缀，动画属性（`-webkit-animation`）和关键帧@规则（`@-webkit-keyframes`）都要用到。这就需要复制出有前缀和无前缀两套代码。可以考虑使用Autoprefixer来实现（见第五章附加栏目"浏览器前缀"）。

## 16.2 为3D变换添加动画

接下来，我们开始在前一章创建的网页上添加动画。完成清单15.10之后，我们已经有了一个蓝色背景的页面，页面左侧有导航菜单。我们会用几张卡片元素来填充页面剩余的部分。我们先完成整个效果图的页面排版，然后再添加动画。

### 16.2.1 创建无动画页面布局

在这个demo中，我们会在页面主区域添加一些卡片（图16.3）。然后再使用3D变换添加动画，使卡片具有飞入效果。

**图16.3 页面主区域添加的卡片**

> [p400 图一]

下面的清单展示了这部分内容的代码，把这些代码添加到页面上`<nav>`元素的后面（为了节省空间，代码中卡片内的文字有删节。如果想要更加贴近图16.3中的快照图片，可以随意添加更多内容）。

**清单16.4 创建`飞入网格`和几张卡片**

> [p401 代码清单一]
>
> Grid container
>
> 网格容器
>
> Cards are also grid items.
>
> 卡片同时也是网格元素

这部分页面由两个部分组成。外层的模块是“飞入网格”（Flyin-Grid），为网格内的元素提供布局，同时还包含了3D飞入效果，接下来会讲到。每个网格元素都是内层的卡片模块的一个实例。卡片模块提供外观样式，包括白色背景、内边距和字体颜色等。

这种排版首选网格布局，接下来就会用到。同时我们也应该考虑到移动设备布局，以及在不支持网格的老式浏览器中基于弹性盒布局的回退方案。我们首先实现移动布局，然后添加弹性盒样式，最后是基于网格的样式。

移动布局效果展示在了图16.4中。在小屏幕上，卡片会占满屏幕的宽度，只留左右两侧一点外边距。

**图16.4 移动布局中，卡片会占满屏幕宽度，叠放在菜单下方**

> [p402 图一]

添加下面的移动样式到样式表中。

**清单16.5 卡片的移动样式**

> [p402 代码清单一]
>
> Adds a small left and right margin around the container
>
> 在容器左右两侧添加很小的外边距
>
> Applies card colors and other details
>
> 为卡片添加颜色和其他细节样式
>
> Specifies the image should fill the card width
>
> 设置图片应该填满整张卡片的宽度

在这样的屏幕尺寸下，飞入网格很容易实现，因为网格元素只需要像普通块级元素一样叠放。每张卡片都设置了白色背景和简单的外观样式。很快我们就会使用媒体查询设置更加复杂的布局。

接下来，我们使用flexbox添加回退布局，这只会应用在较大的屏幕上。这样就比较接近最终的效果图（图16.3）了。添加下面的CSS到样式表中。

**清单16.6 使用基于flexbox的回退布局**

> [p403 代码清单一]
>
> Responsive breakpoint
>
> 响应式布局的断点
>
> Establishes the flex container with wrapping
>
> 建立允许折行的弹性容器
>
> Increases padding on sides
>
> 增加两侧的内边距
>
> Enables flex-grow and sets a flex-basis of 300 px
>
> 允许flex-grow，设置flex-basis为300px

这段代码使用flexbox创建了一个响应式布局。我们设置了`flex-wrap: wrap`，这样弹性元素在同一行放不下的时候允许折行。弹性基准值300px指定了元素的最小宽度，同时`max-width`指定最大宽度，在这些约束下，需要的时候元素就会折行。flex-grow的值为1，允许卡片拉伸填满容器的剩余空间。

卡片模块使用前面添加的移动样式即可，不需要做修改，所有的颜色及其他样式与之前展现一致。

在某些屏幕尺寸下，卡片会与最终的布局效果一样。但如果最后一行的卡片数量少于前面每行的数量，所有卡片的宽度不会完全相同。图16.5描述了这个问题。

**图16.5 使用flexbox不能保证最后一行的卡片与上面的卡片宽度一致**

> [p404 图一]